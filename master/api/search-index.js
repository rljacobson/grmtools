var searchIndex={};
searchIndex["cfgrammar"] = {"doc":"A library for manipulating Context Free Grammars (CFG). It…","i":[[3,"PIdx","cfgrammar","A type specifically for production indices (e.g. a rule…",null,null],[12,"0","","",0,null],[3,"RIdx","","A type specifically for rule indices.",null,null],[12,"0","","",1,null],[3,"SIdx","","A type specifically for symbol indices (within a…",null,null],[12,"0","","",2,null],[3,"TIdx","","A type specifically for token indices.",null,null],[12,"0","","",3,null],[4,"Symbol","","",null,null],[13,"Rule","","",4,null],[13,"Token","","",4,null],[11,"as_storaget","","",1,[[["self"]],["t"]]],[11,"as_storaget","","",0,[[["self"]],["t"]]],[11,"as_storaget","","",2,[[["self"]],["t"]]],[11,"as_storaget","","",3,[[["self"]],["t"]]],[0,"yacc","","",null,null],[4,"YaccKind","cfgrammar::yacc","The particular Yacc variant this grammar makes use of.",null,null],[13,"Original","","The original Yacc style as documented by Johnson,",5,null],[13,"Grmtools","","Similar to the original Yacc style, but allowing…",5,null],[13,"Eco","","The variant used in the Eco language composition editor",5,null],[4,"YaccOriginalActionKind","","",null,null],[13,"UserAction","","Execute user-specified actions attached to each…",6,null],[13,"GenericParseTree","","Automatically create a parse tree instead of…",6,null],[13,"NoAction","","Do not do execute actions of any sort.",6,null],[0,"ast","","",null,null],[3,"GrammarAST","cfgrammar::yacc::ast","An AST representing a grammar. This is built up gradually:…",null,null],[12,"start","","",7,null],[12,"rules","","",7,null],[12,"prods","","",7,null],[12,"tokens","","",7,null],[12,"precs","","",7,null],[12,"avoid_insert","","",7,null],[12,"implicit_tokens","","",7,null],[12,"epp","","",7,null],[12,"programs","","",7,null],[3,"Rule","","",null,null],[12,"name","","",8,null],[12,"pidxs","","",8,null],[12,"actiont","","",8,null],[3,"Production","","",null,null],[12,"symbols","","",9,null],[12,"precedence","","",9,null],[12,"action","","",9,null],[3,"GrammarValidationError","","`GrammarAST` validation errors return an instance of this…",null,null],[12,"kind","","",10,null],[12,"sym","","",10,null],[4,"Symbol","","",null,null],[13,"Rule","","",11,null],[13,"Token","","",11,null],[4,"GrammarValidationErrorKind","","The various different possible grammar validation errors.",null,null],[13,"NoStartRule","","",12,null],[13,"InvalidStartRule","","",12,null],[13,"UnknownRuleRef","","",12,null],[13,"UnknownToken","","",12,null],[13,"NoPrecForToken","","",12,null],[13,"UnknownEPP","","",12,null],[11,"new","","",7,[[],["grammarast"]]],[11,"add_rule","","",7,[[["string"],["self"],["option",["string"]]]]],[11,"add_prod","","",7,[[["option",["string"]],["string"],["self"],["symbol"],["vec",["symbol"]]]]],[11,"add_programs","","",7,[[["string"],["self"]]]],[11,"get_rule","","",7,[[["str"],["self"]],[["rule"],["option",["rule"]]]]],[11,"has_token","","",7,[[["str"],["self"]],["bool"]]],[0,"firsts","cfgrammar::yacc","",null,null],[3,"YaccFirsts","cfgrammar::yacc::firsts","`Firsts` stores all the first sets for a given grammar.…",null,null],[11,"new","","Generates and returns the firsts set for the given grammar.",13,[[["yaccgrammar"]],["self"]]],[11,"firsts","","Return all the firsts for rule `ridx`.",13,[[["self"],["ridx"]],["vob"]]],[11,"is_set","","Returns true if the token `tidx` is in the first set for…",13,[[["tidx"],["self"],["ridx"]],["bool"]]],[11,"is_epsilon_set","","Returns true if the rule `ridx` has epsilon in its first…",13,[[["self"],["ridx"]],["bool"]]],[11,"set","","Ensures that the firsts bit for token `tidx` rule `ridx`…",13,[[["tidx"],["self"],["ridx"]],["bool"]]],[0,"follows","cfgrammar::yacc","",null,null],[3,"YaccFollows","cfgrammar::yacc::follows","`Follows` stores all the Follow sets for a given grammar.…",null,null],[11,"new","","Generates and returns the Follows set for the given grammar.",14,[[["yaccgrammar"]],["self"]]],[11,"follows","","Return the Follows `Vob` for rule `ridx`.",14,[[["self"],["ridx"]],["vob"]]],[11,"is_set","","Returns true if the token `tidx` is in the follow set for…",14,[[["tidx"],["self"],["ridx"]],["bool"]]],[0,"grammar","cfgrammar::yacc","",null,null],[3,"Precedence","cfgrammar::yacc::grammar","",null,null],[12,"level","","",15,null],[12,"kind","","",15,null],[3,"YaccGrammar","","Representation of a `YaccGrammar`. See the top-level…",null,null],[3,"SentenceGenerator","","A `SentenceGenerator` can generate minimal sentences for…",null,null],[4,"AssocKind","","",null,null],[13,"Left","","",16,null],[13,"Right","","",16,null],[13,"Nonassoc","","",16,null],[4,"YaccGrammarError","","",null,null],[13,"YaccParserError","","",17,null],[13,"GrammarValidationError","","",17,null],[6,"PrecedenceLevel","","",null,null],[11,"new","","",18,[[["str"],["yacckind"]],[["yaccgrammarerror"],["result",["yaccgrammarerror"]]]]],[11,"new_with_storaget","","Takes as input a Yacc grammar of `YaccKind` as a `String`…",18,[[["str"],["yacckind"]],[["yaccgrammarerror"],["result",["yaccgrammarerror"]]]]],[11,"prods_len","","How many productions does this grammar have?",18,[[["self"]],["pidx"]]],[11,"iter_pidxs","","Return an iterator which produces (in order from…",18,[[["self"]]]],[11,"prod","","Get the sequence of symbols for production `pidx`. Panics…",18,[[["self"],["pidx"]]]],[11,"prod_len","","How many symbols does production `pidx` have? Panics if…",18,[[["self"],["pidx"]],["sidx"]]],[11,"prod_to_rule","","Return the rule index of the production `pidx`. Panics if…",18,[[["self"],["pidx"]],["ridx"]]],[11,"prod_precedence","","Return the precedence of production `pidx` (where `None`…",18,[[["self"],["pidx"]],[["option",["precedence"]],["precedence"]]]],[11,"start_prod","","Return the production index of the start rule's sole…",18,[[["self"]],["pidx"]]],[11,"rules_len","","How many rules does this grammar have?",18,[[["self"]],["ridx"]]],[11,"iter_rules","","Return an iterator which produces (in order from…",18,[[["self"]]]],[11,"rule_to_prods","","Return the productions for rule `ridx`. Panics if `ridx`…",18,[[["self"],["ridx"]]]],[11,"rule_name","","Return the name of rule `ridx`. Panics if `ridx` doesn't…",18,[[["self"],["ridx"]],["str"]]],[11,"implicit_rule","","Return the `RIdx` of the implict rule if it exists, or…",18,[[["self"]],[["option",["ridx"]],["ridx"]]]],[11,"rule_idx","","Return the index of the rule named `n` or `None` if it…",18,[[["str"],["self"]],[["option",["ridx"]],["ridx"]]]],[11,"start_rule_idx","","What is the index of the start rule? Note that cfgrammar…",18,[[["self"]],["ridx"]]],[11,"tokens_len","","How many tokens does this grammar have?",18,[[["self"]],["tidx"]]],[11,"iter_tidxs","","Return an iterator which produces (in order from…",18,[[["self"]]]],[11,"eof_token_idx","","Return the index of the end token.",18,[[["self"]],["tidx"]]],[11,"token_name","","Return the name of token `tidx` (where `None` indicates…",18,[[["self"],["tidx"]],[["str"],["option",["str"]]]]],[11,"token_precedence","","Return the precedence of token `tidx` (where `None`…",18,[[["self"],["tidx"]],[["option",["precedence"]],["precedence"]]]],[11,"token_epp","","Return the %epp entry for token `tidx` (where `None`…",18,[[["self"],["tidx"]],[["str"],["option",["str"]]]]],[11,"action","","Get the action for production `pidx`. Panics if `pidx`…",18,[[["self"],["pidx"]],["option"]]],[11,"actiontype","","",18,[[["self"],["ridx"]],["option"]]],[11,"programs","","Get the programs part of the grammar",18,[[["self"]],["option"]]],[11,"tokens_map","","Returns a map from names to `TIdx`s of all tokens that a…",18,[[["self"]],[["str"],["tidx"],["hashmap",["str","tidx"]]]]],[11,"token_idx","","Return the index of the token named `n` or `None` if it…",18,[[["str"],["self"]],[["option",["tidx"]],["tidx"]]]],[11,"avoid_insert","","Is the token `tidx` marked as `%avoid_insert`?",18,[[["self"],["tidx"]],["bool"]]],[11,"has_path","","Is there a path from the `from` rule to the `to` rule?…",18,[[["self"],["ridx"]],["bool"]]],[11,"pp_prod","","Returns the string representation of a given production…",18,[[["self"],["pidx"]],["string"]]],[11,"sentence_generator","","Return a `SentenceGenerator` which can then generate…",18,[[["self"],["f"]],["sentencegenerator"]]],[11,"firsts","","Return a `YaccFirsts` struct for this grammar.",18,[[["self"]],["yaccfirsts"]]],[11,"follows","","Return a `YaccFirsts` struct for this grammar.",18,[[["self"]],["yaccfollows"]]],[11,"min_sentence_cost","","What is the cost of a minimal sentence for the rule…",19,[[["self"],["ridx"]],["u16"]]],[11,"max_sentence_cost","","What is the cost of a maximal sentence for the rule…",19,[[["self"],["ridx"]],[["u16"],["option",["u16"]]]]],[11,"min_sentence","","Non-deterministically return a minimal sentence from the…",19,[[["self"],["ridx"]],[["tidx"],["vec",["tidx"]]]]],[11,"min_sentences","","Return (in arbitrary order) all the minimal sentences for…",19,[[["self"],["ridx"]],[["vec",["tidx"]],["vec",["vec"]]]]],[0,"parser","cfgrammar::yacc","",null,null],[3,"YaccParserError","cfgrammar::yacc::parser","Any error from the Yacc parser returns an instance of this…",null,null],[12,"kind","","",20,null],[4,"YaccParserErrorKind","","The various different possible Yacc parser errors.",null,null],[13,"IllegalName","","",21,null],[13,"IllegalString","","",21,null],[13,"IncompleteRule","","",21,null],[13,"DuplicateRule","","",21,null],[13,"IncompleteComment","","",21,null],[13,"IncompleteAction","","",21,null],[13,"MissingColon","","",21,null],[13,"MissingRightArrow","","",21,null],[13,"PrematureEnd","","",21,null],[13,"ProgramsNotSupported","","",21,null],[13,"UnknownDeclaration","","",21,null],[13,"DuplicatePrecedence","","",21,null],[13,"PrecNotFollowedByToken","","",21,null],[13,"DuplicateAvoidInsertDeclaration","","",21,null],[13,"DuplicateImplicitTokensDeclaration","","",21,null],[13,"DuplicateStartDeclaration","","",21,null],[13,"DuplicateActiontypeDeclaration","","",21,null],[13,"DuplicateEPP","","",21,null],[13,"ReachedEOL","","",21,null],[13,"InvalidString","","",21,null],[11,"from","cfgrammar","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"equivalent","","",0,[[["k"],["self"]],["bool"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"equivalent","","",1,[[["k"],["self"]],["bool"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,[[["self"],["t"]]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"equivalent","","",2,[[["k"],["self"]],["bool"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,[[["self"],["t"]]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"equivalent","","",3,[[["k"],["self"]],["bool"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"equivalent","","",4,[[["k"],["self"]],["bool"]]],[11,"from","cfgrammar::yacc","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,[[["self"],["t"]]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,[[["self"],["t"]]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"from","cfgrammar::yacc::ast","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"equivalent","","",9,[[["k"],["self"]],["bool"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"to_string","","",10,[[["self"]],["string"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,[[["self"],["t"]]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"equivalent","","",11,[[["k"],["self"]],["bool"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"type_id","","",12,[[["self"]],["typeid"]]],[11,"from","cfgrammar::yacc::firsts","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"from","cfgrammar::yacc::follows","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"from","cfgrammar::yacc::grammar","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,[[["self"],["t"]]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[],["u"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"type_id","","",19,[[["self"]],["typeid"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,[[["self"],["t"]]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"to_string","","",17,[[["self"]],["string"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"from","cfgrammar::yacc::parser","",20,[[["t"]],["t"]]],[11,"into","","",20,[[],["u"]]],[11,"to_string","","",20,[[["self"]],["string"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"type_id","","",20,[[["self"]],["typeid"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[],["u"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"type_id","","",21,[[["self"]],["typeid"]]],[11,"from","cfgrammar::yacc::grammar","",17,[[["yaccparsererror"]],["yaccgrammarerror"]]],[11,"from","","",17,[[["grammarvalidationerror"]],["yaccgrammarerror"]]],[11,"clone","cfgrammar","",1,[[["self"]],["ridx"]]],[11,"clone","","",0,[[["self"]],["pidx"]]],[11,"clone","","",2,[[["self"]],["sidx"]]],[11,"clone","","",3,[[["self"]],["tidx"]]],[11,"clone","cfgrammar::yacc::ast","",11,[[["self"]],["symbol"]]],[11,"clone","cfgrammar::yacc::grammar","",15,[[["self"]],["precedence"]]],[11,"clone","","",16,[[["self"]],["assockind"]]],[11,"clone","cfgrammar::yacc","",5,[[["self"]],["yacckind"]]],[11,"clone","","",6,[[["self"]],["yaccoriginalactionkind"]]],[11,"clone","cfgrammar","",4,[[["self"]],["symbol"]]],[11,"cmp","","",1,[[["ridx"],["self"]],["ordering"]]],[11,"cmp","","",0,[[["self"],["pidx"]],["ordering"]]],[11,"cmp","","",2,[[["self"],["sidx"]],["ordering"]]],[11,"cmp","","",3,[[["tidx"],["self"]],["ordering"]]],[11,"eq","","",1,[[["ridx"],["self"]],["bool"]]],[11,"ne","","",1,[[["ridx"],["self"]],["bool"]]],[11,"eq","","",0,[[["self"],["pidx"]],["bool"]]],[11,"ne","","",0,[[["self"],["pidx"]],["bool"]]],[11,"eq","","",2,[[["self"],["sidx"]],["bool"]]],[11,"ne","","",2,[[["self"],["sidx"]],["bool"]]],[11,"eq","","",3,[[["tidx"],["self"]],["bool"]]],[11,"ne","","",3,[[["tidx"],["self"]],["bool"]]],[11,"eq","cfgrammar::yacc::ast","",9,[[["self"],["production"]],["bool"]]],[11,"ne","","",9,[[["self"],["production"]],["bool"]]],[11,"eq","","",11,[[["symbol"],["self"]],["bool"]]],[11,"ne","","",11,[[["symbol"],["self"]],["bool"]]],[11,"eq","cfgrammar::yacc::grammar","",15,[[["self"],["precedence"]],["bool"]]],[11,"ne","","",15,[[["self"],["precedence"]],["bool"]]],[11,"eq","","",16,[[["self"],["assockind"]],["bool"]]],[11,"eq","cfgrammar","",4,[[["symbol"],["self"]],["bool"]]],[11,"ne","","",4,[[["symbol"],["self"]],["bool"]]],[11,"partial_cmp","","",1,[[["ridx"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",1,[[["ridx"],["self"]],["bool"]]],[11,"le","","",1,[[["ridx"],["self"]],["bool"]]],[11,"gt","","",1,[[["ridx"],["self"]],["bool"]]],[11,"ge","","",1,[[["ridx"],["self"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["pidx"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",0,[[["self"],["pidx"]],["bool"]]],[11,"le","","",0,[[["self"],["pidx"]],["bool"]]],[11,"gt","","",0,[[["self"],["pidx"]],["bool"]]],[11,"ge","","",0,[[["self"],["pidx"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["sidx"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",2,[[["self"],["sidx"]],["bool"]]],[11,"le","","",2,[[["self"],["sidx"]],["bool"]]],[11,"gt","","",2,[[["self"],["sidx"]],["bool"]]],[11,"ge","","",2,[[["self"],["sidx"]],["bool"]]],[11,"partial_cmp","","",3,[[["tidx"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",3,[[["tidx"],["self"]],["bool"]]],[11,"le","","",3,[[["tidx"],["self"]],["bool"]]],[11,"gt","","",3,[[["tidx"],["self"]],["bool"]]],[11,"ge","","",3,[[["tidx"],["self"]],["bool"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar::yacc::ast","",8,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",9,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",11,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",12,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",10,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar::yacc::firsts","",13,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar::yacc::follows","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar::yacc::grammar","",15,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",16,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",17,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar::yacc::parser","",21,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",20,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar::yacc","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",6,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar::yacc::ast","",10,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",11,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar::yacc::grammar","",17,[[["formatter"],["self"]],["result"]]],[11,"fmt","cfgrammar::yacc::parser","",20,[[["formatter"],["self"]],["result"]]],[11,"hash","cfgrammar","",1,[[["self"],["__h"]]]],[11,"hash","","",0,[[["self"],["__h"]]]],[11,"hash","","",2,[[["self"],["__h"]]]],[11,"hash","","",3,[[["self"],["__h"]]]],[11,"hash","cfgrammar::yacc::ast","",11,[[["self"],["__h"]]]],[11,"hash","cfgrammar","",4,[[["self"],["__h"]]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",2,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","cfgrammar::yacc::grammar","",15,[[["self"],["__s"]],["result"]]],[11,"serialize","","",16,[[["self"],["__s"]],["result"]]],[11,"serialize","","",18,[[["self"],["__s"]],["result"]]],[11,"serialize","cfgrammar","",4,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result"]]],[11,"deserialize","","",0,[[["__d"]],["result"]]],[11,"deserialize","","",2,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","cfgrammar::yacc::grammar","",15,[[["__d"]],["result"]]],[11,"deserialize","","",16,[[["__d"]],["result"]]],[11,"deserialize","","",18,[[["__d"]],["result"]]],[11,"deserialize","cfgrammar","",4,[[["__d"]],["result"]]]],"p":[[3,"PIdx"],[3,"RIdx"],[3,"SIdx"],[3,"TIdx"],[4,"Symbol"],[4,"YaccKind"],[4,"YaccOriginalActionKind"],[3,"GrammarAST"],[3,"Rule"],[3,"Production"],[3,"GrammarValidationError"],[4,"Symbol"],[4,"GrammarValidationErrorKind"],[3,"YaccFirsts"],[3,"YaccFollows"],[3,"Precedence"],[4,"AssocKind"],[4,"YaccGrammarError"],[3,"YaccGrammar"],[3,"SentenceGenerator"],[3,"YaccParserError"],[4,"YaccParserErrorKind"]]};
searchIndex["lrlex"] = {"doc":"","i":[[3,"LexerBuilder","lrlex","A `LexerBuilder` allows one to specify the criteria for…",null,null],[3,"LexerDef","","This struct represents, in essence, a .l file in memory.…",null,null],[3,"Rule","","",null,null],[12,"tok_id","","If `Some`, the ID that lexemes created against this rule…",0,null],[12,"name","","This rule's name. If None, then text which matches this…",0,null],[12,"re_str","","",0,null],[12,"re","","",0,null],[3,"LexBuildError","","Any error from the Lex parser returns an instance of this…",null,null],[12,"kind","","",1,null],[4,"LexErrorKind","","The various different possible Lex parser errors.",null,null],[13,"PrematureEnd","","",2,null],[13,"RoutinesNotSupported","","",2,null],[13,"UnknownDeclaration","","",2,null],[13,"MissingSpace","","",2,null],[13,"InvalidName","","",2,null],[13,"DuplicateName","","",2,null],[13,"RegexError","","",2,null],[5,"build_lex","","",null,[[["str"]],[["lexerdef"],["lexbuilderror"],["result",["lexerdef","lexbuilderror"]]]]],[11,"new","","Create a new `LexerBuilder`.",3,[[],["self"]]],[11,"mod_name","","Set the generated module name to `mod_name`. If no module…",3,[[["str"]],["self"]]],[11,"rule_ids_map","","Set this lexer builder's map of rule IDs to…",3,[[["hashmap",["string"]],["string"]],["self"]]],[11,"process_file_in_src","","Given the filename `a/b.l` as input, statically compile…",3,[[["str"]],[["result",["box"]],["box",["error"]]]]],[11,"process_file","","Statically compile the `.l` file `inp` into Rust, placing…",3,[[["q"],["p"]],[["result",["box"]],["box",["error"]]]]],[11,"allow_missing_terms_in_lexer","","If passed false, tokens used in the grammar but not…",3,[[["bool"]],["self"]]],[11,"allow_missing_tokens_in_parser","","If passed false, tokens defined in the lexer but not used…",3,[[["bool"]],["self"]]],[11,"new","","",4,[[["vec",["rule"]],["rule"]],["lexerdef"]]],[11,"get_rule","","Get the `Rule` at index `idx`.",4,[[["self"],["usize"]],[["rule"],["option",["rule"]]]]],[11,"get_rule_by_id","","Get the `Rule` instance associated with a particular…",4,[[["self"],["storaget"]],["rule"]]],[11,"get_rule_by_name","","Get the `Rule` instance associated with a particular name.",4,[[["str"],["self"]],[["rule"],["option",["rule"]]]]],[11,"set_rule_ids","","Set the id attribute on rules to the corresponding value…",4,[[["self"],["hashmap"]]]],[11,"iter_rules","","Returns an iterator over all rules in this AST.",4,[[["self"]],[["iter",["rule"]],["rule"]]]],[11,"lexer","","Return a lexer for the `String` `s` that will lex relative…",4,[[["str"],["self"]]]],[6,"LexBuildResult","","",null,null],[14,"lrlex_mod","","A convenience macro for including statically compiled `.l`…",null,null],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[],["result"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[],["result"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]]],"p":[[3,"Rule"],[3,"LexBuildError"],[4,"LexErrorKind"],[3,"LexerBuilder"],[3,"LexerDef"]]};
searchIndex["lrpar"] = {"doc":"`lrpar` provides a Yacc-compatible parser (where grammars…","i":[[3,"LexError","lrpar","A Lexing error.",null,null],[3,"Lexeme","","A `Lexeme` represents a segment of the user's input that…",null,null],[3,"CTParserBuilder","","A `CTParserBuilder` allows one to specify the criteria for…",null,null],[3,"ParseError","","Records a single parse error.",null,null],[3,"RTParserBuilder","","A run-time parser builder.",null,null],[3,"Span","","A `Span` records what portion of the user's input…",null,null],[4,"LexParseError","","A lexing or parsing error. Although the two are quite…",null,null],[13,"LexError","","",0,null],[13,"ParseError","","",0,null],[4,"Node","","A generic parse tree.",null,null],[13,"Term","","Terminals store a single lexeme.",1,null],[12,"lexeme","lrpar::Node","",2,null],[13,"Nonterm","lrpar","Nonterminals reference a rule and have zero or more…",1,null],[12,"ridx","lrpar::Node","",3,null],[12,"nodes","","",3,null],[4,"ParseRepair","lrpar","After a parse error is encountered, the parser attempts to…",null,null],[13,"Insert","","Insert a `Symbol::Token`.",4,null],[13,"Delete","","Delete a symbol.",4,null],[13,"Shift","","Shift a symbol.",4,null],[4,"RecoveryKind","","What recovery algorithm should be used when a syntax error…",null,null],[13,"CPCTPlus","","The CPCT+ algorithm from Diekmann/Tratt \"Don't Panic!…",5,null],[13,"None","","Don't use error recovery: return as soon as the first…",5,null],[11,"new","","Create a new `CTParserBuilder`.",6,[[],["self"]]],[11,"new_with_storaget","","Create a new `CTParserBuilder`.",6,[[],["self"]]],[11,"mod_name","","Set the generated module name to `mod_name`. If no module…",6,[[["str"]],["self"]]],[11,"recoverer","","Set the recoverer for this parser to `rk`.",6,[[["recoverykind"]],["self"]]],[11,"yacckind","","Set the `YaccKind` for this parser to `ak`.",6,[[["yacckind"]],["self"]]],[11,"error_on_conflicts","","If set to true, `process_file_in_src` will return an error…",6,[[["bool"]],["self"]]],[11,"conflicts","","If there are any conflicts in the grammar, return a tuple…",6,[[["self"]],["option"]]],[11,"process_file_in_src","","Given the filename `a/b.y` as input, statically compile…",6,[[["str"],["self"]],[["result",["hashmap","box"]],["hashmap",["string"]],["box",["error"]]]]],[11,"process_file","","Statically compile the Yacc file `inp` into Rust, placing…",6,[[["self"],["q"],["p"]],[["result",["hashmap","box"]],["hashmap",["string"]],["box",["error"]]]]],[11,"new","","",7,[[["span"]],["self"]]],[11,"span","","",7,[[["self"]],["span"]]],[11,"new","","Create a new token with ID `tok_id` and a starting…",8,[[["option",["usize"]],["storaget"],["usize"]],["self"]]],[11,"tok_id","","The token ID.",8,[[["self"]],["storaget"]]],[11,"start","","Byte offset of the start of the lexeme",8,[[["self"]],["usize"]]],[11,"end","","Byte offset of the end of the lexeme.",8,[[["self"]],["usize"]]],[11,"len","","Length in bytes of the lexeme.",8,[[["self"]],["usize"]]],[11,"span","","",8,[[["self"]],["span"]]],[11,"inserted","","Returns `true` if this lexeme was inserted as the result…",8,[[["self"]],["bool"]]],[11,"pp","","Return a pretty-printed version of this node.",1,[[["str"],["self"],["yaccgrammar"]],["string"]]],[11,"pp","","A pretty-printer of a lexer/parser error. This isn't…",0,[[["lexer"],["self"],["fn"]],["string"]]],[11,"new","","Create a new run-time parser from a `YaccGrammar`, a…",9,[[["stategraph"],["statetable"],["yaccgrammar"]],["self"]]],[11,"recoverer","","Set the recoverer for this parser to `rk`.",9,[[["recoverykind"]],["self"]]],[11,"term_costs","","",9,[[["fn"]],["self"]]],[11,"parse_generictree","","Parse input, and (if possible) return a generic parse…",9,[[["lexer"],["self"]]]],[11,"parse_noaction","","Parse input, returning any errors found. See the arguments…",9,[[["lexer"],["self"]],[["vec",["lexparseerror"]],["lexparseerror"]]]],[11,"parse_actions","","Parse input, execute actions, and return the associated…",9,[[["self"],["lexer"]]]],[11,"stidx","","Return the state table index where this error was detected.",10,[[["self"]],["stidx"]]],[11,"lexeme","","Return the lexeme where this error was detected.",10,[[["self"]],["lexeme"]]],[11,"repairs","","Return the repairs found that would fix this error. Note…",10,[[["self"]],["vec"]]],[8,"Lexer","","The trait which all lexers which want to interact with…",null,null],[10,"iter","","Iterate over all the lexemes in this lexer. Note that: *…",11,[[["self"]],[["box",["iterator"]],["iterator"]]]],[10,"span_str","","Return the user input associated with a `Span`.",11,[[["span"],["self"]],["str"]]],[10,"span_lines_str","","Return the lines containing the input at `span` (including…",11,[[["span"],["self"]],["str"]]],[10,"line_col","","Return `((start line, start column), (end line, end…",11,[[["span"],["self"]]]],[11,"new","","Create a new span starting at byte `start` and ending at…",12,[[["usize"]],["self"]]],[11,"start","","Byte offset of the start of the span.",12,[[["self"]],["usize"]]],[11,"end","","Byte offset of the end of the span.",12,[[["self"]],["usize"]]],[11,"len","","Length in bytes of the span.",12,[[["self"]],["usize"]]],[14,"lrpar_mod","","A convenience macro for including statically compiled `.y`…",null,null],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,[[["self"],["t"]]]],[11,"to_string","","",7,[[["self"]],["string"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[],["result"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,[[["self"],["t"]]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"equivalent","","",8,[[["k"],["self"]],["bool"]]],[11,"try_into","","",8,[[],["result"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[],["result"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,[[["self"],["t"]]]],[11,"to_string","","",10,[[["self"]],["string"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[],["result"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[],["result"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,[[["self"],["t"]]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"type_id","","",12,[[["self"]],["typeid"]]],[11,"equivalent","","",12,[[["k"],["self"]],["bool"]]],[11,"try_into","","",12,[[],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[],["result"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"equivalent","","",4,[[["k"],["self"]],["bool"]]],[11,"try_into","","",4,[[],["result"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,[[["self"],["t"]]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[],["result"]]],[11,"from","","",0,[[["lexerror"]],["lexparseerror"]]],[11,"from","","",0,[[["parseerror"]],["lexparseerror"]]],[11,"clone","","",7,[[["self"]],["lexerror"]]],[11,"clone","","",8,[[["self"]],["lexeme"]]],[11,"clone","","",1,[[["self"]],["node"]]],[11,"clone","","",5,[[["self"]],["recoverykind"]]],[11,"clone","","",4,[[["self"]],["parserepair"]]],[11,"clone","","",10,[[["self"]],["parseerror"]]],[11,"clone","","",12,[[["self"]],["span"]]],[11,"eq","","",8,[[["self"],["lexeme"]],["bool"]]],[11,"ne","","",8,[[["self"],["lexeme"]],["bool"]]],[11,"eq","","",1,[[["node"],["self"]],["bool"]]],[11,"ne","","",1,[[["node"],["self"]],["bool"]]],[11,"eq","","",4,[[["self"],["parserepair"]],["bool"]]],[11,"ne","","",4,[[["self"],["parserepair"]],["bool"]]],[11,"eq","","",10,[[["self"],["parseerror"]],["bool"]]],[11,"ne","","",10,[[["self"],["parseerror"]],["bool"]]],[11,"eq","","",12,[[["span"],["self"]],["bool"]]],[11,"ne","","",12,[[["span"],["self"]],["bool"]]],[11,"fmt","","",7,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",8,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",10,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",12,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",7,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",10,[[["formatter"],["self"]],["result"]]],[11,"hash","","",8,[[["self"],["__h"]]]],[11,"hash","","",4,[[["self"],["__h"]]]]],"p":[[4,"LexParseError"],[4,"Node"],[13,"Term"],[13,"Nonterm"],[4,"ParseRepair"],[4,"RecoveryKind"],[3,"CTParserBuilder"],[3,"LexError"],[3,"Lexeme"],[3,"RTParserBuilder"],[3,"ParseError"],[8,"Lexer"],[3,"Span"]]};
searchIndex["lrpar_tests"] = {"doc":"","i":[],"p":[]};
searchIndex["lrtable"] = {"doc":"","i":[[3,"StateGraph","lrtable","",null,null],[3,"StIdx","","StIdx is a wrapper for a state index. Its internal type is…",null,null],[4,"Minimiser","","",null,null],[13,"Pager","","",0,null],[5,"from_yacc","","",null,[[["yaccgrammar"],["minimiser"]],[["result",["statetableerror"]],["statetableerror"]]]],[11,"iter_stidxs","","Return an iterator which produces (in order from…",1,[[["self"]],[["box",["iterator"]],["iterator"]]]],[11,"closed_state","","Return the itemset for closed state `stidx`. Panics if…",1,[[["stidx"],["self"]],["itemset"]]],[11,"iter_closed_states","","Return an iterator over all closed states in this…",1,[[["self"]],[["box",["iterator"]],["iterator"]]]],[11,"core_state","","Return the itemset for core state `stidx` or `None` if it…",1,[[["stidx"],["self"]],["itemset"]]],[11,"iter_core_states","","Return an iterator over all core states in this…",1,[[["self"]],[["box",["iterator"]],["iterator"]]]],[11,"all_states_len","","How many states does this `StateGraph` contain? NB: By…",1,[[["self"]],["stidx"]]],[11,"edge","","Return the state pointed to by `sym` from `stidx` or…",1,[[["stidx"],["symbol"],["self"]],[["stidx"],["option",["stidx"]]]]],[11,"edges","","Return the edges for state `stidx`. Panics if `stidx`…",1,[[["stidx"],["self"]],["hashmap"]]],[11,"all_edges_len","","How many edges does this `StateGraph` contain?",1,[[["self"]],["usize"]]],[11,"pp","","Pretty print this stategraph as a `String`. If…",1,[[["yaccgrammar"],["self"],["bool"]],["string"]]],[11,"pp_core_states","","Return a pretty printed version of the core states, and…",1,[[["yaccgrammar"],["self"]],["string"]]],[11,"pp_closed_states","","Return a pretty printed version of the closed states, and…",1,[[["yaccgrammar"],["self"]],["string"]]],[0,"statetable","","",null,null],[3,"Conflicts","lrtable::statetable","",null,null],[3,"StateTableError","","Any error from the Yacc parser returns an instance of this…",null,null],[12,"kind","","",2,null],[12,"pidx","","",2,null],[3,"StateTable","","A representation of a `StateTable` for a grammar.…",null,null],[12,"final_state","","",3,null],[3,"StateActionsIterator","","",null,null],[3,"CoreReducesIterator","","",null,null],[4,"StateTableErrorKind","","The various different possible Yacc parser errors.",null,null],[13,"AcceptReduceConflict","","",4,null],[4,"Action","","",null,null],[13,"Shift","","Shift to state X in the statetable.",5,null],[13,"Reduce","","Reduce production X in the grammar.",5,null],[13,"Accept","","Accept this input.",5,null],[13,"Error","","No valid action.",5,null],[11,"sr_conflicts","","Return an iterator over all shift/reduce conflicts.",6,[[["self"]]]],[11,"rr_conflicts","","Return an iterator over all reduce/reduce conflicts.",6,[[["self"]]]],[11,"sr_len","","How many shift/reduce conflicts are there?",6,[[["self"]],["usize"]]],[11,"rr_len","","How many reduce/reduce conflicts are there?",6,[[["self"]],["usize"]]],[11,"pp","","Returns a pretty-printed version of the conflicts.",6,[[["yaccgrammar"],["self"]],["string"]]],[11,"new","","",3,[[["yaccgrammar"],["stategraph"]],[["result",["statetableerror"]],["statetableerror"]]]],[11,"action","","Return the action for `stidx` and `sym`, or `None` if…",3,[[["stidx"],["self"],["tidx"]],["action"]]],[11,"state_actions","","Return an iterator over the indexes of all non-empty…",3,[[["stidx"],["self"]],["stateactionsiterator"]]],[11,"state_shifts","","Return an iterator over the indexes of all shift actions…",3,[[["stidx"],["self"]],["stateactionsiterator"]]],[11,"reduce_only_state","","Does the state `stidx` 1) only contain reduce (and error)…",3,[[["stidx"],["self"]],["bool"]]],[11,"core_reduces","","Return an iterator over a set of \"core\" reduces of…",3,[[["stidx"],["self"]],["corereducesiterator"]]],[11,"goto","","Return the goto state for `stidx` and `ridx`, or `None` if…",3,[[["stidx"],["self"],["ridx"]],[["stidx"],["option",["stidx"]]]]],[11,"conflicts","","Return a struct containing all conflicts or `None` if…",3,[[["self"]],[["option",["conflicts"]],["conflicts"]]]],[6,"StIdxStorageT","lrtable","The type of the inner value of an StIdx.",null,null],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[],["result"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,[[["self"],["t"]]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"equivalent","","",7,[[["k"],["self"]],["bool"]]],[11,"try_into","","",7,[[],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[],["result"]]],[11,"from","lrtable::statetable","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[],["result"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[],["result"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"into_iter","","",8,[[],["i"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[],["result"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"into_iter","","",9,[[],["i"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[],["result"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[],["result"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,[[["self"],["t"]]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[],["result"]]],[11,"from","lrtable","",7,[[["stidxstoraget"]],["self"]]],[11,"from","","",10,[[["stidx"]],["self"]]],[11,"next","lrtable::statetable","",8,[[["self"]],[["option",["tidx"]],["tidx"]]]],[11,"next","","",9,[[["self"]],[["pidx"],["option",["pidx"]]]]],[11,"clone","","",5,[[["self"]],["action"]]],[11,"clone","lrtable","",7,[[["self"]],["stidx"]]],[11,"clone","","",0,[[["self"]],["minimiser"]]],[11,"eq","lrtable::statetable","",5,[[["self"],["action"]],["bool"]]],[11,"ne","","",5,[[["self"],["action"]],["bool"]]],[11,"eq","lrtable","",7,[[["self"],["stidx"]],["bool"]]],[11,"ne","","",7,[[["self"],["stidx"]],["bool"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","lrtable::statetable","",6,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","lrtable","",7,[[["formatter"],["self"]],["result"]]],[11,"fmt","lrtable::statetable","",2,[[["formatter"],["self"]],["result"]]],[11,"hash","lrtable","",7,[[["self"],["__h"]]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","lrtable::statetable","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","","",5,[[["self"],["__s"]],["result"]]],[11,"serialize","lrtable","",7,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result"]]],[11,"deserialize","lrtable::statetable","",6,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","","",5,[[["__d"]],["result"]]],[11,"deserialize","lrtable","",7,[[["__d"]],["result"]]]],"p":[[4,"Minimiser"],[3,"StateGraph"],[3,"StateTableError"],[3,"StateTable"],[4,"StateTableErrorKind"],[4,"Action"],[3,"Conflicts"],[3,"StIdx"],[3,"StateActionsIterator"],[3,"CoreReducesIterator"],[6,"StIdxStorageT"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);